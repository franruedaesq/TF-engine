# Proposal: Migrating TF-Engine to Rust

This document outlines a strategy to rewrite the core logic of `tf-engine` in Rust while maintaining full backward compatibility with the existing TypeScript API. The goal is to leverage Rust's performance and safety for the heavy math and graph traversal operations, without requiring users to refactor their existing code.

## 1. Executive Summary

We propose to replace the internal logic of `TFTree` and `BufferedTFTree` with a WebAssembly (WASM) module compiled from Rust.

To ensure **zero-refactor** for users:

1. We will **retain the existing TypeScript classes** (`Vec3`, `Quaternion`, `Transform`) as the data carriers and public API.
2. The `TFTree` class will act as a **wrapper/facade** around the underlying Rust WASM instance.
3. Data (transforms, vectors) will be marshaled between TypeScript and Rust seamlessly.

## 2. Architecture

### 2.1. The Rust Core (`packages/core/src-rust`)

We will introduce a Rust crate that implements the heavy lifting:

- **Graph Data Structure**: Stores the frame hierarchy.
- **Math**: Uses `glam` (a high-performance graphics math library) to handle `Vec3`, `Quat`, and `Mat4` operations.
- **Algorithms**: Implements `get_transform` (LCA search + composition) and `buffered_lookup` (interpolation) in Rust.

### 2.2. The TypeScript Bridge (`packages/core/src`)

The existing TypeScript files will remain but will be modified to delegate logic to the WASM module.

- **`Vec3`, `Quaternion`, `Transform`**: strictly kept as TypeScript classes. This avoids the need for users to manually manage memory (calling `.free()`) for these small, frequent objects.
- **`TFTree`**: Will hold a reference to the Rust `TfTreeWasm` struct. Methods like `addFrame` or `getTransform` will call into WASM, converting TS objects to raw numbers/arrays for Rust, and reconstructing TS objects from Rust's return values.

## 3. Technology Stack

- **Language**: Rust (2021 edition)
- **Compilation Target**: WebAssembly (`wasm32-unknown-unknown`)
- **Build Tool**: `wasm-pack`
- **Math Crate**: `glam` (simd-optimized where supported, maps well to `gl-matrix`)
- **Interop**: `wasm-bindgen`
- **Serialization**: `serde` + `serde-wasm-bindgen` (for `toJSON`/`fromJSON`)

## 4. Implementation Details

### 4.1. Rust Structs

```rust
// lib.rs (Pseudo-code)

use wasm_bindgen::prelude::*;
use glam::{Vec3, Quat, Mat4};
use std::collections::HashMap;

#[wasm_bindgen]
pub struct TfTreeWasm {
    frames: HashMap<String, FrameNode>,
    // ... cache and dirty flags
}

#[wasm_bindgen]
impl TfTreeWasm {
    #[wasm_bindgen(constructor)]
    pub fn new() -> TfTreeWasm { ... }

    pub fn add_frame(&mut self, id: &str, parent_id: Option<String>, tx: f32, ty: f32, tz: f32, rx: f32, ry: f32, rz: f32, rw: f32) -> Result<(), String> {
        // Implementation
    }

    pub fn get_transform(&self, from: &str, to: &str) -> Result<Vec<f64>, String> {
        // Returns [tx, ty, tz, rx, ry, rz, rw]
    }
}
```

### 4.2. TypeScript Integration

We keep the existing `TFTree.ts` but modify its implementation:

```typescript
// packages/core/src/TFTree.ts

import { TfTreeWasm } from "./wasm/pkg"; // Generated by wasm-pack
import { Transform } from "./math/Transform";

export class TFTree implements ITransformTree {
  private wasmTree: TfTreeWasm;

  constructor() {
    this.wasmTree = new TfTreeWasm();
  }

  addFrame(id: string, parentId?: string, transform = Transform.identity()): void {
    const { translation: t, rotation: r } = transform;
    // Pass raw components to Rust to avoid overhead of object serialization
    this.wasmTree.add_frame(id, parentId, t.x, t.y, t.z, r.x, r.y, r.z, r.w);
  }

  getTransform(from: string, to: string): Transform {
    // Get raw array [tx, ty, tz, rx, ry, rz, rw]
    const raw = this.wasmTree.get_transform(from, to);
    return Transform.fromArray(raw); // We would add a helper or use existing constructors
  }

  // ... implement other methods similarly
}
```

### 4.3. Building and Loading

Since WASM loading can be asynchronous (in browsers) or synchronous (in Node), we need a strategy.

- **Bundlers (Vite/Webpack)**: Use standard WASM import support.
- **Node.js**: Read the `.wasm` file and compile synchronously.

To keep usage simple (`new TFTree()`), we might need to bundle the WASM inline (base64) or use a synchronous initialization pattern if targeting Node.js mostly. For strictly async browser environments, we might need to introduce an async `init()` function, but that would change the API.

- _Solution for unchanged API_: `wasm-bindgen` supports generating code that works with bundlers that handle async loading transparently, OR we can use a small JS shim that loads the WASM synchronously in Node and asynchronously (but awaited before app start) in Browser. Given this is a library, the "async init" problem is the biggest hurdle for a drop-in replacement.
  - **Proposed Solution**: Use `wasm-pack build --target nodejs` for the NPM package (CommonJS/ESM for Node). For browser usage, we rely on the user's bundler (Vite/Webpack) to handle the WASM import, or provide a `initTFEngine()` promise that users must await before using the library if they are in a pure browser environment without a smart bundler.

## 5. Migration Plan

1.  **Setup Rust Environment**:
    - Create `packages/core/rust` directory.
    - Initialize `Cargo.toml`.
    - Add `glam`, `wasm-bindgen`, `serde`.

2.  **Port Math Logic (Optional/Internal)**:
    - While we keep TS Math classes, the Rust side needs equivalent logic for `compose`, `invert`, `lerp`, `slerp`. `glam` provides most of this out of the box.

3.  **Port TFTree Logic**:
    - Implement the graph (Map of frames).
    - Implement `add_frame`, `remove_frame`.
    - Implement `get_transform` (LCA finding).
    - Implement `update_transform`.

4.  **Port BufferedTFTree Logic**:
    - Implement the ring buffer for transforms in Rust.
    - Implement `get_transform_at` with interpolation.

5.  **Generate Bindings**:
    - Run `wasm-pack build`.
    - Verify generated `.d.ts` and `.js` files.

6.  **Wire up TypeScript**:
    - Update `TFTree.ts` to import from the generated WASM package.
    - Translate inputs/outputs.

7.  **Testing**:
    - Run existing Vitest suite. It should pass without modification if the API is preserved correctly.
    - Add benchmarks to compare JS vs Rust performance.

## 6. Benefits vs Risks

**Benefits**:

- **Performance**: `getTransform` in O(depth) will be much faster in Rust, especially for deep trees or heavy query loads.
- **Safety**: Rust's type system prevents many runtime errors.
- **Portability**: The core logic can be reused in other languages (Python bindings via PyO3, etc.) in the future.

**Risks**:

- **WASM Overhead**: Crossing the JS-WASM boundary has a cost. For very simple operations (like adding two vectors), JS might be faster. We strictly reserve Rust for the "heavy" tree traversals and batched updates.
- **Build Complexity**: Adds a Rust toolchain requirement for contributors.
- **Async Loading**: The biggest API challenge. If the environment requires async WASM instantiation, the synchronous `new TFTree()` API might need to change to `await TFTree.create()` or require a global `await init()` at app startup.

## 7. Recommendation

Proceed with the migration, treating `packages/core` as a hybrid package. Use `wasm-pack` with the `bundler` target for maximum compatibility with modern web tools, and providing a fallback or specific build for Node.js.
